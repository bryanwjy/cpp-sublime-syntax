%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: formal-C++
scope: formal.c++

file_extensions:
  - cpp
  - cc
  - cp
  - cxx
  - c++
  - C
  - h
  - hh
  - hpp
  - hxx
  - h++
  - inl
  - ipp
  - ixx
  - cppm

variables:
  identifier: '\b[[:alpha:]_][[:alnum:]_]*\b'
  nested-name-specifier-var: '(?:::\s*)?(?:{{identifier}}\s*::\s*)*'
  native-simple-type-specifier: 'char|char8_t|char16_t|char32_t|wchar_t|bool|short|int|long|signed|unsigned|float|double|void'
  # number digits
  bin_digit: '[01'']'
  oct_digit: '[0-7'']'
  dec_digit: '[\d'']'
  hex_digit: '[\h'']'
  dec_digits: '(?:\d(?:{{dec_digit}}*\d)?)'
  # number exponents
  dec_exponent: '(?:[eE][-+]?{{dec_digit}}*)'
  hex_exponent: '(?:[pP][-+]?{{dec_digit}}*)'
  bin_suffix: '[2-9a-zA-Z_][[:alnum:]_]*'
  oct_suffix: '[8-9g-zG-Z_][[:alnum:]_]*'
  dec_suffix: '[a-zA-Z_][[:alnum:]_]*'
  hex_suffix: '[g-zG-Z_][[:alnum:]_]*'
  float_suffix: '[fF]'

  macro_identifier: \b[[:upper:]_][[:upper:][:digit:]_]{2,}\b # only uppercase, at least 3 chars
  # type-id-regex:

contexts:
  main:
    - include: comments

  # Not a real nested-name-specifier since there isn't enough context to parse it
  nested-name-specifier:
    # type-name
    - match: '\bclass\b'
      scope: keyword.declaration.class.c++
    - match: '\bunion\b'
      scope: keyword.declaration.union.c++
    - match: '\benum\b'
      scope: keyword.declaration.enum.c++
    # computed-type-specifier
    - match: '\bdecltype\b'
      scope: keyword.operator.word.c++
      push:
        - match: '\('
          scope: meta.group.c++ punctuation.section.group.begin.c++
          push:
            - match: '\)'
              scope: meta.group.c++ punctuation.section.group.end.c++
              pop: 2
            - include: expression
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
          pop: true
    - match: '(\.\.\.)(?=\[)' # for pack argument index in C++26
      captures:
        1: keyword.operator.variadic.c++
      push:
        - meta_content_scope: meta.template.c++.pack-index
        - match: '\['
          scope: punctuation.section.brackets.begin.c++
          set:
            - match: '\]'
              scope: punctuation.section.brackets.end.c++
              pop: true
            - include: constant-expression
    # nested
    - match: '(?:(::)\s*)?(?:{{identifier}}\s*(::)\s*)*'
      captures:
        1: punctuation.accessor.double-colon.c++
        2: punctuation.accessor.double-colon.c++
    - match: '\btemplate\b'
      scope: keyword.declaration.c++
      push:
        - include: simple-template-id
        - match: '(?=\S)'
          pop: true
    - include: simple-template-id

  template-argument-list:
    - match: ','
      scope: punctuation.separator.c++
      push:
        - match: '>|\.\.\.'
          scope: invalid.illegal.unexpected-character.c++
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '\.\.\.'
      scope: keyword.operator.variadic.c++
      push:
        - match: '(?=(,|>))'
          pop: true
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
          pop: true
    - include: template-argument

  template-argument:
    - match: '(?=\{)'
      push:
        - include: braced-init-list
        - match: '(?=\S)'
          pop: true
    - include: type-id
    - include: id-expression
    - include: constant-expression

  simple-template-id:
    - match: '{{identifier}}'
      scope: variable.other.template-name
      push:
        - match: '<'
          scope: punctuation.definition.generic.begin meta.template.c++
          set:
            - match: '>'
              scope: punctuation.definition.generic.end meta.template.c++
              pop: true
            - include: template-argument-list
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
          pop: true

  type-id:


  balanced-token-seq:
    - match: ','
      scope: punctuation.separator.c++
    - match: '\('
      scope: meta.group.c++ punctuation.section.group.begin.c++
      push:
        - match: '\)'
          scope: meta.group.c++ punctuation.section.group.end.c++
          pop: true
        - include: balanced-token-seq
    - match: '\['
      scope: meta.group.c++ punctuation.section.group.begin.c++
      push:
        - match: '\]'
          scope: meta.group.c++ punctuation.section.group.end.c++
          pop: true
        - include: balanced-token-seq
    - match: '{'
      scope: meta.group.c++ punctuation.section.group.begin.c++
      push:
        - match: '}'
          scope: meta.group.c++ punctuation.section.group.end.c++
          pop: true
        - include: balanced-token-seq
    - include: number-literals
    - include: string-literals
    # - match: '{{identifier}}'
  
  attribute-list:
    - match: ','
      scope: punctuation.separator.c++
    - match: '\.\.\.'
      scope: keyword.operator.variadic.c++
    - match: '({{identifier}})(::)'
      captures:
        1: variable.other.attribute.c++
        2: punctuation.accessor.double-colon.c++
    - match: '({{identifier}})(\()'
      captures:
        1: variable.other.attribute.c++
        2: meta.group.c++ punctuation.section.group.begin.c++
      push:
        - match: '\)'
          scope: meta.group.c++ punctuation.section.group.end.c++
          pop: true
        - include: balanced-token-seq
    - match: '{{identifier}}'
      scope: variable.other.attribute.c++

  attribute-specifier:
    - match: '\[\[' # attribute-specifier-seq
      scope: punctuation.section.brackets.begin.c++
      push:
        - meta_content_scope: meta.attributes.c++
        - match: '\]\]'
          scope: punctuation.section.brackets.end.c++
          pop: true
        - match: '\busing\b'
          scope: keyword.control.c++
          set:
            - match: '{{identifier}}'
              set:
                - match: ':'
                  scope: punctuation.separator.c++
                  set:
                    - match: '(?=\]\])'
                      pop: true
                    - match: '::'
                      scope: invalid.illegal.unexpected-character.c++
                    - include: attribute-list
                - match: '(?=\S)'
                  scope: invalid.illegal.unexpected-character.c++
        - include: attribute-list
  
  attribute-specifier-seq:
    - include: attribute-specifier

  type-specifier-seq:


  type-specifier:
    


  simple-type-specifier:

  elaborate-type-specifier:

  typename-specifier:
    - match: '\btypename\b'
      scope: keyword.declaration.c++

  cv-qualifier:
    - match: '\b(?:const|volatile)\b'
      scope: storage.modifier.c++

  type-id-continue:
    - match: '(?=(\[|alignas))'
      set: attribute-specifier-seq


  cv-qualifier-seq:
    - include: cv-qualifier
    - match: '(?=\S)'
      pop: true

  noptr-new-declarator:
    - match: '\['
      scope: punctuation.section.brackets.begin.c++
      push:
        - match: '\]'
          scope: punctuation.section.brackets.end.c++
          pop: true
        - include: expression
        - include: constant-expression
    - include: attribute-specifier-seq

  ptr-operator:
    - match: '\*'
      set:
        - include: attribute-specifier-seq
        - include: cv-qualifier-seq
    - match: '&&'
      set:
        - include: attribute-specifier-seq
    - match: '&'
      set:
        - include: attribute-specifier-seq
    - match: '{{nested-name-specifier-var}}'
      set:
        - include: attribute-specifier-seq
        - include: cv-qualifier-seq

  declarator-id:
    - match: '\.\.\.'
      scope: keyword.operator.variadic.c++
      set: id-expression
    - include: id-expression

  declarator-alt:
    - match: '{{noptr-declarator-prefix}}'
      set:
        - match: '\('
          scope: meta.group.c++ punctuation.section.group.begin.c++
          push:
            - match: '\)'
              scope: meta.group.c++ punctuation.section.group.end.c++
              pop: true
            - include: p-parameter-declaration-clause
        - match: '(?:const|volatile)'
          scope: storage.modifier.c++
          set:
            - match: '(&{0-2})' # ref

  declarator:
    - match: '(?={{noptr-declarator-prefix}})'
      set: declarator-alt
    - include: ptr-declarator

  new-declarator:
    - include: ptr-operator
    - include: noptr-new-declarator

  new-initializer:
    - match: '\('
      scope: meta.group.c++ punctuation.section.group.begin.c++
      push:
        - match: '\)'
          scope: meta.group.c++ punctuation.section.group.end.c++
          pop: true
        - match: '(?=\S)'
          push: expression-list
    - match: '(?={)'
      set:
        - include: braced-init-list
        - match: '(?=\S)'
          pop: true

  expression-list:
    - match: '(?=\))'
      scope: punctuation.definition.block.end.c++
      pop: true
    - match: '(?<!\()),'
      scope: punctuation.separator.c++
    - match: '(?<!(\(|,))\.\.\.'
      scope: keyword.operator.variadic.c++
      push:
        - match: '(?=(,|\)))'
          pop: true
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
    - match: '(?=\S)'
      push: initializer-clause

  new-type-id:
    - include: new-declarator
    - match: '(?=\S)'
      push: type-specifier-seq

  new-expression:
    - match: '(?:(::)\s*)?\b(new)\b'
      captures:
        1: punctuation.accessor.global-namespace.c++
        2: keyword.control.c++
      push:
        - include: comments
        - match: '\('
          scope: meta.group.c++ punctuation.section.group.begin.c++
          push:
            - match: '\)'
              scope: meta.group.c++ punctuation.section.group.end.c++
              pop: true
            - include: type-id
            - include: expression-list
        - match: '(?=\{)'
          set:
            - include: braced-init-list
            - match: '(?=\S)'
              pop: true
        - include: new-type-id
        - match: '(?=\S)'
          pop: true

  delete-expression:
    - match: '(?:(::)\s*)?\b(delete)\b\s*([])?'
      captures:
        1: punctuation.accessor.global-namespace.c++
        2: keyword.control.c++
        3: keyword.control.c++
      push:
        - include: comments
        - include: cast-expression
        - match: '(?=\S)'
          pop: true

  sizeof-expression:
    - match: '\bsizeof\b'
      scope: keyword.operator.word.c++
      push:
        - match: '\.\.\.'
          scope: keyword.operator.variadic.c++
          set:
            - match: '\('
              scope: meta.group.c++ punctuation.section.group.begin.c++
              set:
                - match: '{{identifier}}'
                  scope: variable.parameter.template.pack.c++
                  set:
                    - match: '\)'
                      scope: meta.group.c++ punctuation.section.group.end.c++
                      pop: true
            - match: '(?=\S)'
              scope: invalid.illegal.unexpected-character.c++
              pop: true
        - match: '\('
          scope: meta.group.c++ punctuation.section.group.begin.c++
          set:
            - match: '\)'
              scope: meta.group.c++ punctuation.section.group.end.c++
              pop: true
            - include: type-id
            - include: unary-expression

  alignof-expression:
    - match: '\balignof\b'
      scope: keyword.operator.word.c++
      push: 
        - match: '\('
          scope: meta.group.c++ punctuation.section.group.begin.c++
          set:
            - match: '\)'
              scope: meta.group.c++ punctuation.section.group.end.c++
              pop: true
            - include: type-id
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
          pop: true

  noexcept-expression:
    - match: '\bnoexcept\b'
      scope: keyword.operator.word.c++
      push:
        - match: '\('
          scope: meta.group.c++ punctuation.section.group.begin.c++
          push:
            - match: '\)'
              scope: meta.group.c++ punctuation.section.group.end.c++
              pop: 2
            - include: expression
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
          pop: true

  await-expression:
    - match: '\bco_await\b'
      scope: keyword.control.c++
      push:
        - include: cast-expression
        - match: '(?=\S)'
          pop: true

  unary-expression:
    - include: comments
    - match: '(!|~)' #'(\*|&|+|-|!|~)'
      scope: keyword.operator.arithmetic.c++
    - match: '(\+\+|--)'
      scope: keyword.operator.arithmetic.c++
    - include: await-expression
    - include: sizeof-expression
    - include: alignof-expression
    - include: noexcept-expression
    - include: new-expression
    - include: delete-expression
    - include: postfix-expression

  cast-expression:
    - include: comments
    - match: '\('
      scope: meta.group.c++ punctuation.section.group.begin.c++
      push:
        - match: '\)'
          scope: meta.group.c++ punctuation.section.group.end.c++
          pop: true
        - include: type-id
        - include: expression
    - include: unary-expression

  pm-expression:
    - include: cast-expression
    - match: '(\.\*|->\*)'
      scope: punctuation.accessor.c++

  multiplicative-expression:
    - include: pm-expression
    - match: '(/|%)'
      scope: keyword.operator.arithmetic.c++
    - match: '\*'
      scope: keyword.operator.c++

  additive-expression:
    - include: multiplicative-expression
    - match: '(+|-)'
      scope: keyword.operator.arithmetic.c++

  shift-expression:
    - include: additive-expression
    - match: '(<<|>>)'
      scope: keyword.operator.bitwise.c++

  compare-expression:
    - include: shift-expression
    - match: '<=>'
      scope: keyword.operator.comparison.c++

  relational-expression:
    - include: compare-expression
    - match: '(<(?!(=|<))|>(?!>)|<=(?!>)|>=)'
      scope: keyword.operator.comparison.c++

  equality-expression:
    - include: relational-expression
    - match: '(==|!=)'
      scope: keyword.operator.comparison.c++

  and-expression:
    - include: equality-expression
    - match: '&(?!&)'
      scope: keyword.operator.c++

  exclusive-or-expression:
    - include: and-expression
    - match: '^(?!=)'
      scope: keyword.operator.bitwise.c++

  inclusive-or-expression:
    - include: exclusive-or-expression
    - match: '\|(?!\|)'
      scope: keyword.operator.bitwise.c++

  logical-and-expression:
    - include: inclusive-or-expression
    - match: '&&'
      scope: keyword.operator.logical.c++ keyword.operator.logical.c

  logical-or-expression:
    - include: logical-and-expression
    - match: '\|\|'
      scope: keyword.operator.logical.c++ keyword.operator.logical.c

  brace-or-equal-initializer:
    - match: '='
      scope: keyword.operator.assignment.c++
      set:
        - include: initializer-clause
        - match: '(?=\S)'
          pop: true
    - match: '(?=\{)'
      set: 
        - include: braced-init-list
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      scope: invalid.illegal.unexpected-character.c++
      pop: true

  designated-initializer-clause:
    - match: '(\.)\s*({{identifier}})'
      captures:
        1: punctuation.accessor.c++.designated-initializer
        2: variable.other.member
      push: brace-or-equal-initializer
    - match: '(?=\S)'
      scope: invalid.illegal.unexpected-character.c++

  designated-initializer-list:
    - match: '(?=})'
      scope: punctuation.definition.block.end.c++
      pop: true
    - match: ','
      scope: punctuation.separator.c++
    - include: designated-initializer-clause

  initializer-clause:
    - match: '(?=\{)'
      push:
        - include: braced-init-list
        - match: '(?=\S)'
          pop: true
    - include: assignment-expression
    
  initializer-list:
    - match: '(?=})'
      scope: punctuation.definition.block.end.c++
      pop: true
    - match: '(?<!{),'
      scope: punctuation.separator.c++
    - match: '(?<!({|,))\.\.\.'
      scope: keyword.operator.variadic.c++
      push:
        - match: '(?=(,|}))'
          pop: true
        - match: '(?=\S)'
          scope: invalid.illegal.unexpected-character.c++
    - include: initializer-clause

  braced-init-list:
    - match: '{'
      scope: punctuation.definition.block.begin.c++
      push:
        - match: '}' # For empty initializer list
          scope: punctuation.definition.block.end.c++
          pop: true
        - match: '(?=\.\s*{{identifier}})'
          push: designated-initializer-list
        - match: '(?=\S)'
          push: initializer-list
    - match: '(?=\S)'
      scope: invalid.illegal.unexpected-character.c++

  yield-expression:
    - match: '\bco_yield\b'
      captures: keyword.control.c++.coroutine
      set:
        - match: '(?=\{)'
          set:
            - include: braced-init-list
            - match: '(?=\S)'
              pop: true
        - match: '(?=\S)'
          set: assignment-expression

  throw-expression:
    - match: '\bthrow\b'
      scope: keyword.control.c++.exception
      set:
        - include: assignment-expression
        - match: ';' # Might not be needed here
          scope: punctuation.terminator.c++

  assignment-expression:
    - match: '(?=\bthrow\b)'
      set: throw-expression
    - match: '(?=\bco_yield\b)'
      set: yield-expression
    # conditional-expression
    # logical-or-expression ? expression : assignment-expression
    - match: '(=|*=|/=|%=|+=|-=|>>=|<<=|&=|^=|\|=)'
      scope: keyword.operator.assignment.c++
      set: initializer-clause
    - match: '(?=\?)'
      set:
        - match: ':'
          scope: keyword.operator.ternary.c++
          set: assignment-expression
        - match: '\?'
          scope: keyword.operator.ternary.c++
          push: expression
    - match: '(?=\S)'
      push: logical-or-expression

  expression:
    - match: '(?=\S)'
      set: assignment-expression

  expression-continue:
    - match: ','
      scope: keyword.operator.arithmetic.c++
      set: assignment-expression
    - match: '(?=\S)'
      pop: true


  conditional-expression:
    - match: '(?=\S)'
      set: logical-or-expression

  conditional-expression-continue:
    - include: comments
    - match: '(?=\?)'
      push:
        - match: '\?'
          scope: keyword.operator.ternary.c++
          push: expression
        - match: '(?=\S)'
          set:
            - match: ':'
              scope: keyword.operator.ternary.c++
              set: assignment-expression
            - match: '(?=\S)'
              scope: invalid.illegal.unexpected-character.c++

  constant-expression:
    - include: conditional-expression

  comments:
    - include: line-comment
    - include: block-comment

  line-comment:
    - match: '//.*'
      scope: comment.line.double-slash.c++

  block-comment:
    - match: '/\*'
      scope: comment.block.c++ comment.block.c
      push:
        - match: '\*/'
          scope: comment.block.c++ comment.block.c
          pop: true
        - match: '.'
          scope: comment.block.content.c++

  raw-string-literals:
    - match: '((?:L|u8|u|U)?R)("([^\(\)\\ ]{0,16})\()'
      captures:
        1: storage.type.string.c++
        2: punctuation.definition.string.begin.c++
      push:
        - meta_scope: string.quoted.double.c++
        - match: '\)\3"'
          scope: punctuation.definition.string.end.c++
          pop: true

  string-literals:
    - match: '(L|u8|u|U)?(")'
      captures:
        1: storage.type.string.c++
        2: punctuation.definition.string.begin.c++
      push:
        - meta_scope: string.quoted.double.c++
        - match: '"'
          scope: punctuation.definition.string.end.c++
          pop: true
        - include: string-escaped-char
        - include: string-placeholder
    - match: "(L|u8|u|U)?(')"
      captures:
        1: storage.type.string.c++
        2: punctuation.definition.string.begin.c++
      push:
        - meta_scope: string.quoted.single.c++
        - match: "'"
          scope: punctuation.definition.string.end.c++
          pop: true
        - include: string-escaped-char
    - include: raw-string-literals

  string-escaped-char:
    - match: '(\\)$\n'
      captures:
        1: punctuation.separator.continuation.c
    - match: \\(?:\\|[abefnrtv\'"?]|[0-3][0-9]{0,2}|[4-7][0-9]?|x[a-fA-F0-9]+|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8})
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c++

  string-placeholder:
    - match: |-
        (?x)%
          (\d+\$)?                                      # field (argument #)
          [#0\- +']*                                    # flags
          [,;:_]?                                       # separator character (AltiVec)
          ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
          (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
          (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
          (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
      scope: constant.other.placeholder.c++

  number-literals:
    - match: |-
        (?x:
          \b({{dec_digits}})
          (?:
            ( (\.)
              (?:
                # 1.1, 1.1e1, 1.1e-1, 1.1f, 1.1e1f, 1.1e-1f, 1.1L, 1.1e1L, 1.1e-1L
                {{dec_digit}}+ {{dec_exponent}}?
                # 1.e1, 1.e-1, 1.e1f, 1.e-1f, 1.e1L, 1.e-1L
                | {{dec_exponent}}
                # 1., 1.f, 1.L # but not `..`
                | (?!\.)
              )
              # 1e1 1e1f 1e1L
              | {{dec_exponent}}
            ) ({{dec_suffix}})?
            # 1f
            | ({{float_suffix}})
          )
          # .1, .1e1, .1e-1, .1f, .1e1f, .1e-1f, .1L, .1e1L, .1e-1L
          | ( (\.) {{dec_digit}}+ {{dec_exponent}}? ) ({{dec_suffix}})?
        )
      scope: meta.number.float.decimal.c++
      captures:
        1: constant.numeric.value.c++
        2: constant.numeric.value.c++
        3: punctuation.separator.decimal.c++
        4: constant.numeric.suffix.c++
        5: constant.numeric.suffix.c++
        6: constant.numeric.value.c++
        7: punctuation.separator.decimal.c++
        8: constant.numeric.suffix.c++

    # hexadecimal float
    - match: \b(0[xX])({{hex_digit}}*(\.){{hex_digit}}*{{hex_exponent}})({{dec_suffix}})?
      scope: meta.number.float.hexadecimal.c++
      captures:
        1: constant.numeric.base.c++
        2: constant.numeric.value.c++
        3: punctuation.separator.decimal.c++
        4: constant.numeric.suffix.c++

    # https://en.cppreference.com/w/cpp/language/integer_literal

    # hexadecimal integer
    - match: \b(0[xX])({{hex_digit}}*)({{hex_suffix}})?
      scope: meta.number.integer.hexadecimal.c++
      captures:
        1: constant.numeric.base.c++
        2: constant.numeric.value.c++
        3: constant.numeric.suffix.c++

    # binary integer (C++14)
    - match: \b(0[bB])({{bin_digit}}*)({{bin_suffix}})?
      scope: meta.number.integer.binary.c++
      captures:
        1: constant.numeric.base.c++
        2: constant.numeric.value.c++
        3: constant.numeric.suffix.c++

    # octal integer
    - match: \b(0)({{oct_digit}}+)({{oct_suffix}})?
      scope: meta.number.integer.octal.c++
      captures:
        1: constant.numeric.base.c++
        2: constant.numeric.value.c++
        3: constant.numeric.suffix.c++

    # decimal integer
    - match: \b({{dec_digits}})({{dec_suffix}})?
      scope: meta.number.integer.decimal.c++
      captures:
        1: constant.numeric.value.c++
        2: constant.numeric.suffix.c++